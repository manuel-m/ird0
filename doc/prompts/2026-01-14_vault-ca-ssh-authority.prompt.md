**Context**


Currently, the application authenticates to SFTP servers using SSH private keys stored as files on disk

Secrets management is already handled by HashiCorp Vault, and the application is able to communicate with Vault.

**Objective**

I want to completely remove file-based SSH keys from the application and migrate to ephemeral SSH certificates generated by HashiCorp Vault using the SSH Secrets Engine (CA mode).
Vault become mandatory

The new solution must:

Avoid storing any SSH private key on disk

Generate SSH key pairs dynamically at runtime

Request short-lived SSH certificates from Vault (with TTL)

Automatically renew or reissue certificates before expiration

Integrate cleanly with Spring Integration SFTP

**Expected Output**

Please provide:

A recommended architecture for using Vault SSH Secrets Engine (CA mode) with Spring Boot

Java code examples for:

Generating ephemeral SSH key pairs in memory

Calling Vault to sign a public key and retrieve an SSH certificate

Injecting the private key + certificate into a custom SFTP SessionFactory

A strategy for certificate lifecycle management, including renewal or rotation

Security best practices and pitfalls to avoid when replacing file-based SSH keys

Any known limitations of Spring Integration SFTP regarding SSH certificates and how to work around them

**Constraints**


HashiCorp Vault (SSH Secrets Engine, CA mode)

No SSH key material stored on the filesystem

Production-grade security (auditing, short TTL, revocation)

**Goal**

Ensure Vault become mandatory
Provide a clear, production-ready approach to migrate from static SSH keys stored as files to Vault-managed, short-lived SSH certificates, while keeping the existing SFTP integration reliable and maintainable.